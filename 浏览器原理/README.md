### JavaScript引擎中的执行上下文是如何运行的
> 参考冴羽的博客

在执行一段Javascript代码时，JS引擎首先会创建一个执行栈(Execution Stack)

然后JS引擎会创建一个全局执行上下文，并push到执行栈中，这个过程JS引擎会为这段代码中的所有变量分配内存并赋一个初始值(undefined), 在创建阶段完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。

如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行的过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其他函数的调用时，JS引擎会在父函数执行的过程中，将子函数的函数执行上下文push到执行栈。

还有一种特殊情况，在子函数执行的过程中，父函数已经return，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这些变量/常量，当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。

最后，JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS时如何执行的。比如setTimeout和fetch请求都是非阻塞的(通过await可以实现阻塞，比如借助await实现sleep函数)，当异步调用代码触发时，JS引擎会将需要异步执行的代码移除调用栈，直到等待到返回结果，JS引擎会将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立即将任务队列中的回调函数逐个push进调用栈并执行，这个过程我们也称之为事件循环。

### 为什么很多站点第二次打开速度会很快
> 极客时间《浏览器工作原理与实践》, 掘金小册子《前端性能优化原理与实践》

主要原因是第一次加载页面过程中，缓存了一些耗时的数据，后续访问的时候直接从这些缓存中读取数据，而不是像第一次一样对源站请求数据。那么哪些数据会被缓存呢？

#### DNS缓存
主要就是在浏览器本地把对应的 IP 和域名关联起来，这样在DNS解析的时候就很快

#### 缓存位置: MemoryCache
内存缓存是一种比较特殊的缓存，它不受 HTTP Header Cache-Control 字段的max-age、no-cache 等字段的影响，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。但这种缓存是暂时的，一旦关闭浏览器，这部分用于缓存的内存空间就会被释放掉。如果 Cache-Control 配置为 no-store,即便是内存缓存也不会生效

谷歌开发者工具的Network面板中资源的Size字段，即可判断该资源是否从内存缓存或磁盘缓存中读取

#### 缓存位置: DiskCache
相较内存缓存而言时效性更长，当内存不充裕时，请求资源大概率被缓存到 Disk cache

#### 缓存策略: 强缓存
强缓存通过HTTP相应头中的Cache-Control max-age 字段来实现，客户端在第一次成功收到响应数据后，之后在 max-age 定义的时间返回内，请求同样的资源都会使用本地缓存

#### 缓存策略: 协商缓存
协商缓存依赖于服务端与浏览器之间的通信。Cache-Control配置为 no-cache(表示不使用Cache-Control来控制缓存，而使用Last-Modified和ETag来控制缓存) 时即启用协商缓存。

协商缓存机制下，浏览器需要向服务器去循环缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动(Not Modified), 资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。

协商缓存的实现包括`Last-Modified`和`ETag`, Last-Modified是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着Response Header返回，随后浏览器每次请求时，都会带上一个 If-Modified-Since的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值

服务器接受到这个时间戳以后，会对比该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在响应头中添加新的Last-Modified值，反则还是只返回一个 304 响应

使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：

* 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。

* 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。

这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。

Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。

Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。

Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。

### 事件循环
1. 执行JS脚本或者触发DOM事件都是宏任务，会执行相关代码
2. 执行过程成中的宏任务(setTimeout等)会进入宏任务队列，promise的回调函数等会进入微任务队列

3. 在宏任务执行过程中，如果执行栈为空(比如点击按钮操作，因为冒泡所以会依次触发按钮和父级容器的onClick函数，两次函数中间执行栈会空闲一会儿)，则立即执行微任务队列中的所有微任务

4. 在宏任务结束时，执行队列中的微任务

5. 浏览器进行UI渲染

6. 处理宏任务队列中的剩余宏任务，回到 1

### 浏览器重绘与重排中的队列机制
很多浏览器会维护一个队列，把所有会引起repaint与reflow的操作放入这个队列，等队列中的操作累积了一定数量，或者到了一定的时间间隔，浏览器就会对这个队列进行批处理。这样就会让多次重绘变成一次。

当js想要获得dom的一些属性时，浏览器为了给出最精确的值，会flush队列，及把缓冲区的数据强行输出。
像这些属性：

- offsetTop, offsetLeft, offsetWidth, offsetHeight
- scrollTop/Left/Width/Height
- clientTop/Left/Width/Height
- width,height

参考 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24

### 浏览器事件循环和Node事件循环的区别
参考 https://juejin.cn/post/6844903761949753352#heading-12

从宏任务和微任务的角度来看，Node10及之前的版本，只要宏任务队列里有宏任务，就会执行队列中所有的宏任务后，再执行微任务； Node11 之后，与浏览器的行为一致，每执行完一个宏任务，就执行微任务队列中的所有微任务
